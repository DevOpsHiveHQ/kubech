#
# This script is meant to be sourced in shell config file e.g. ".bashrc" in bash.
#
# Kubech is a simple tool that lets you set contexts/namespaces per shell/terminal.
# That's help you to manage multi Kubernetes cluster at the same time.


#
# Vars.
KUBECONFIG_ORIG="${KUBECONFIG:-$HOME/.kube/config}"
KUBECONFIG_SRC_DIR="${KUBECONFIG_SRC_DIR:-$HOME/.kube/config.src.d}"
KUBECONFIG_DEST_DIR="${KUBECONFIG_DEST_DIR:-$HOME/.kube/config.dest.d}"
KUBECONFIG_ACTIVE=""
KUBECH_NAMESPACE_CHECK="${KUBECH_NAMESPACE_CHECK:-list}"


#
# Usage.
kubech () {
  cat <<EOF
NOTE:
  - The command "kubech" is just a meta for other commands. So kubech does nothing by itself.
  - Also short names like "kchc/kchn/kchu" are available.

VARS:
  KUBECONFIG_SRC_DIR     : Set directory with extra kubectl config files to read in kubech commands.
                           This allow to have multiple config files in addition to
                           the one at "\$HOME/.kube/config".
                           Default: "${KUBECONFIG_SRC_DIR}"
  KUBECONFIG_DEST_DIR    : Set directory for temporary kubectl config files. The files
                           in this directory are auto-generated by kubech commands
                           and you don't need to interact with them or even change that var.
                           Default: "${KUBECONFIG_DEST_DIR}"
  KUBECH_NAMESPACE_CHECK : Method used to check if namespace exists before switching to it.
                           The default lists all namespaces which can be slow in large
                           clusters. After kubernetes 1.22+ all namespaces have a label
                           that can be used to speed this up. Set to "label" to enable this.
                           Available options: "list", "label".
                           Default: "${KUBECH_NAMESPACE_CHECK}"

USAGE:
  kubechc             : List all contexts
  kubechc <CONTEXT>   : Switch to context <CONTEXT>
  kubechn             : List all namespaces
  kubechn <NAMESPACE> : Switch to namespace <NAMESPACE>
  kubechu             : Unset the active context. This is just a safty net
                        to avoid applying config by mistake to the wrong cluster.
EOF
}


#
# General.

# Create config dirs.
mkdir -p "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"
chmod 744 "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"


#
# Handeling Kube config files.
_kubeconfig_files () {
    if [ -d "${KUBECONFIG_SRC_DIR}" ]; then
        KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -print | tr '\n' ':')"
    fi
    echo "${KUBECONFIG_FILES}${KUBECONFIG_ORIG}"
}

_kube_config () {
    KUBECONFIG_DEFAULT="$(_kubeconfig_files)"
    if [ -n "${1}" ]; then
        if [[ "${KUBECONFIG}" == "${KUBECONFIG_ACTIVE}" ]]; then
            export KUBECONFIG="${1}:${KUBECONFIG_DEFAULT}"
        else
            export KUBECONFIG="${1}:${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        fi
        KUBECONFIG_ACTIVE="${KUBECONFIG}"

    elif [ -n "${KUBECONFIG}" ]; then
        KUBECONFIG_ACTIVE="${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        echo "${KUBECONFIG_ACTIVE}"

    else
        KUBECONFIG_ACTIVE="${KUBECONFIG_DEFAULT}:${KUBECONFIG_ORIG}"
        echo "${KUBECONFIG_ACTIVE}"
    fi
}


#
# Remove non-alphanumeric characters in kubeconfig filename for certain kube context.
_kube_context_filename () {
  kube_context="${1}"
  kube_namespace="${2}"
  kube_context_filename=$(echo "${kube_context}" | tr -c '[:alnum:]\n' '_')

  echo "${kube_context_filename}-${kube_namespace}.yaml"
}


#
# Generate kubectl config for a single context.
_kubechg () {
    kube_context="${1}"
    kube_namespace="${2:-default}"
    kubeconfig_file="$(_kube_context_filename "${kube_context}" "${kube_namespace}")"

    touch "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
    chmod 600 "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"

    KUBECONFIG="$(_kube_config)"    \
    kubectl config view             \
        --minify                    \
        --flatten                   \
        --context="${kube_context}" > \
        "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
}


#
# Change kubectl context.
kubechc () {
    kube_context="${1}"
    kube_namespace="${2:-default}"

    if [[ -n "${kube_context}" ]]; then
        _kubechg "${kube_context}" "${kube_namespace}"
        _kube_config "${KUBECONFIG_DEST_DIR}/$(_kube_context_filename "${kube_context}" "${kube_namespace}")"
        # kubectl config current-context
    else
        KUBECONFIG=$(_kube_config) kubectl config get-contexts --no-headers=true -o name
    fi
}

alias kchc='kubechc'


#
# Change kubectl namespace
kubechn () {
    kube_namespace="${1:-default}"
    if [[ "${KUBECH_NAMESPACE_CHECK}" == "label" ]]; then
        kube_namespace_exists=$(kubectl get namespaces -l "kubernetes.io/metadata.name=${kube_namespace}" -o name)
    else
        kube_namespace_all=$(kubectl get namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')
        kube_namespace_exists=$(echo "${kube_namespace_all}" | grep -E "^${kube_namespace}$")
    fi

    if [[ -n ${1} ]]; then
        # Only switch namespace if it exists.
        if [[ -n "${kube_namespace_exists}" ]]; then
            kubechc "$(kubectl config current-context)" "${kube_namespace}"
            kubectl config set-context --current --namespace="${kube_namespace}"
            echo "Switched to namespace \"${kube_namespace}\""
        else
            echo "The namespace \"${kube_namespace}\" doesn't exist"
        fi
    else
        if [[ -n "${kube_namespace_all}" ]]; then
            echo "${kube_namespace_all}" 
        else
            kubectl get namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
        fi
    fi
}

alias kchn='kubechn'


#
# Unset the active context.
kubechu () {
    kubectl config unset current-context
}

alias kchu='kubechu'

#
# Remove auto-generated kubeconf files from kubech dist dir.
kubechr () {
    ls "${KUBECONFIG_DEST_DIR}"/*.yaml &&
    rm "${KUBECONFIG_DEST_DIR}"/*.yaml
}

alias kchr='kubechr'
